---
title: Expect
---

import FunctionRenderer from "@site/src/components/FunctionRenderer";
import MatcherRenderer from "@site/src/components/MatcherRenderer";

import {
	expect,
	toBe,
	toBeDefined,
	toBeUndefined,
	toBeFalsy,
	toBeTruthy,
	toBeInstanceOf,
	toEqual,
	toHaveBeenCalled,
	toHaveBeenCalledTimes,
	toHaveBeenCalledWith,
	toHaveBeenLastCalledWith,
	toHaveBeenNthCalledWith,
	toHaveReturned,
	toHaveReturnedTimes,
	toHaveReturnedWith,
	toHaveLastReturnedWith,
	toHaveNthReturnedWith,
	toBeCloseTo,
	toBeGreaterThan,
	toBeGreaterThanOrEqual,
	toBeLessThan,
	toBeLessThanOrEqual,
	toBeNaN,
	toBeInfinity,
	toHaveLength,
	toContain,
	toContainEqual,
	toMatchObject,
	toMatch,
	toThrow,
} from "@lest/docs";

<FunctionRenderer {...expect} headingLevel="h2">

```lua
test("returns hello world", function()
	expect(someFunction()).toBe("hello world!")
end)
```

</FunctionRenderer>

## Modifiers

### `.never`

If you need to invert the result of a matcher you can use the `.never` modifier. For example, the code below tests that the answer to life, the universe, and everything is _never_ 42:

```lua
test("doesn't return 42", function()
	expect(deepThought()).never.toBe(42)
end)
```

Note that as with calling matchers directly on `expect()`, you use `.` instead of `:` as Lest binds the received value to the function internally.

:::info

This is the same as the `.not` modifier in Jest. We had to use `never` as `not` is a reserved keyword in Lua.

:::

## Equality Matchers

<MatcherRenderer {...toBe}></MatcherRenderer>

<MatcherRenderer {...toEqual}></MatcherRenderer>

<MatcherRenderer {...toBeDefined}></MatcherRenderer>

<MatcherRenderer {...toBeUndefined}></MatcherRenderer>

<MatcherRenderer {...toBeTruthy}></MatcherRenderer>

<MatcherRenderer {...toBeFalsy}></MatcherRenderer>

<MatcherRenderer {...toBeInstanceOf}></MatcherRenderer>

## Mock Function Matchers

<MatcherRenderer {...toHaveBeenCalled}></MatcherRenderer>

<MatcherRenderer {...toHaveBeenCalledTimes}></MatcherRenderer>

<MatcherRenderer {...toHaveBeenCalledWith}></MatcherRenderer>

<MatcherRenderer {...toHaveBeenLastCalledWith}></MatcherRenderer>

<MatcherRenderer {...toHaveBeenNthCalledWith}></MatcherRenderer>

<MatcherRenderer {...toHaveReturned}></MatcherRenderer>

<MatcherRenderer {...toHaveReturnedTimes}></MatcherRenderer>

<MatcherRenderer {...toHaveReturnedWith}></MatcherRenderer>

<MatcherRenderer {...toHaveLastReturnedWith}></MatcherRenderer>

<MatcherRenderer {...toHaveNthReturnedWith}></MatcherRenderer>

## Number Matchers

<MatcherRenderer {...toBeCloseTo}></MatcherRenderer>

<MatcherRenderer {...toBeGreaterThan}></MatcherRenderer>

<MatcherRenderer {...toBeGreaterThanOrEqual}></MatcherRenderer>

<MatcherRenderer {...toBeLessThan}></MatcherRenderer>

<MatcherRenderer {...toBeLessThanOrEqual}></MatcherRenderer>

<MatcherRenderer {...toBeNaN}></MatcherRenderer>

<MatcherRenderer {...toBeInfinity}></MatcherRenderer>

## String Matchers

:::info
Some [table matchers](#table-matchers) also work with strings - e.g. [`.toHaveLength()`](#.toHaveLength)
:::

<MatcherRenderer {...toMatch}></MatcherRenderer>

## Table Matchers

<MatcherRenderer {...toHaveLength}></MatcherRenderer>

<MatcherRenderer {...toContain}></MatcherRenderer>

<MatcherRenderer {...toContainEqual}></MatcherRenderer>

<MatcherRenderer {...toMatchObject}></MatcherRenderer>

## Function Matchers

<MatcherRenderer {...toThrow}></MatcherRenderer>
